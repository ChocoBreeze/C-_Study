
-동적 계획법(Dynamic Programming)
  -분할 정복 패러다임 개념을 확장한 것으로, 특정 분류의 문제에 사용됨.
  -직관적인 작업 방식을 크게 뛰어넘는 통찰력을 선사하기도 함.
  -예시 : 조합(특정 기준을 만족하는 시퀀스 조합 or 순열 개수 구하기), 문자열과 시퀀스, 그래프, 머신 러닝
  
-동적 계획법이란?
  예시 : 피보나치 수열
    F(n) = F(n-1) + F(n-2) --> 재귀 관계(recurrence relation)를 표현.
    처음 두 원소인 F(0), F(1)은 기저 조건(base case)라 부르며 재귀 없이 해를 구할 수 있는 지점.
    -top-down solution(하향식 해법) : 맨 꼭대기에서 시작하여 기저 조건에 닿을 때까지 아래쪽 가지로 이동.
      피보나치 수열에서는 중복되는 부분 문제라는 특성이 존재..
        --> 일반적인 분할 정복 문제(전체가 독립적인 부분 문제로 나뉨)와 동적 계획법 문제(같은 부분 문제가 반복적으로 드러남)를 구분하는 특성 중 하나가 된다.
        
    -최적 부분 구조(optimal substructure)
      동적 계획법 문제를 정의하는 두 번째 특성으로 전체 문제에 대한 최적해가 부분 문제의 최적해의 조합으로 표현이 가능할 때 최적 부분 구조를 갖는다고 말한다.
      
    동적 계획법 문제에서는 중복되는 문제 특성으로 인해 입력이 증가함에 따라 복잡도가 기하급수적으로 증가 --> 이전에 해결한 부분 문제에 해답을 Cache에 저장한다.
    --> Memoization
    
  <접근 방법>
    1.Memoization(하향식 접근 방법) : 하향식 방식에서 부분 문제의 해를 캐시에 넣어 사용하는 기술로써 모든 동적 계획법 문제에 적용이 가능하다.
      다음 조건을 만족한다 가정
      1. 고유한 특성은 유지하면서 서로 다른 상태의 유사성을 활용하는 캐시 사용 방식 고안 가능 
        -->같은 의미의 부분 문제 해법을 정확하게 일치시켜 저장해야함 And 캐시 사용 방법이 유용하려면 너무 특정 상태에 치우치지 않도록 동작해야 함
      2. 사용가능한 스택 공간을 초과하기 전에 필요한 모든 부분 문제의 해답을 누적 가능.
        -->Stack overflow(너무 많은 재귀 호출)
    
    *어떠한 방법을 사용하기 앞서 잠재적인 복잡도를 평가하기.

    2.Tabulation(Memoization과 반대 방식의 접근) : 기저 조건 해답부터 시작하여 모든 부분 문제에 대한 해답을 표에 저장한 후 재사용하는 방식.
      각각의 부분 문제를 재귀적으로 표현할 수 있어야 하기 때문에 Memoization보다 개념적으로 어렵게 느껴진다. --> 상당한 창의력이 필요.
      임의의 여러 상태를 참조해야 하는 경우 Tabulation이 최선의 방법이 될 수 있다.
  
  <예시> : subset sum problem(부분집합의 합 문제)
    합이 특정 값이 되도록 하는 부분집합 구하기..
    
    <풀이과정>
      1단계 : 동적 계획법 필요조건 분석하기
        1)중복되는 부분 문제 : 최종해(Final solution)는 여러 개의 부분 문제 조합으로 표현이 가능해야 함, But 분할 정복과는 달리 특정 부분 문제가 여러 번 발생 가능
        2)최적 부분 구조 : 주어진 문제에 대한 최적해(optimal solution)는 부분 문제의 최적해로부터 생성 가능.
        
        부분 집합의 합 문제는 두 속성을 모두 만족!
      
      2단계 : 기조 조건과 상태 정의하기
        상태(state)를 구성하기 위해 필요한 것이 무엇인지 파악하기. 즉, 각 부분 문제를 다른 부분 문제와 다르다고 판단할 수 있는 기준찾기
        문제가 어떻게 구성되어 있는지 명확한 이해가 중요(by 전수 조사, 백트래킹, 메모이제이션, 타뷸레이션)
        
          (a) Brute-Force(전수조사)
            단순성 --> 최대한 단순하게 접근..
            정답 비교를 위한 수단
            부분 문제를 시각화 하는 능력, 즉 pattern 찾기
          
          (b) Backtracking : 모든 부분 문제 중에서 유요하지 않은 모든 경우를 제거 하는 방법
            -주어진 문제의 기저 조건과 상태의 재귀적 표현을 결정해야 함 --> 동적 계획법을 적용할 때 도움이 됨.
          
          (c) Memoization :  캐시를 사용해서 부분 문제의 답 저장.
            일반적인 방법 :
              1) 정수 인덱스 사용하는 일반 배열
              2) 언어에서 제공하는 해시 테이블 or 해시 맵
              3) 자체 해시 함수로 만든 해시 테이블 or 해시 맵
              *일반적으로 속도는 배열, 벡터 > 맵이며, 상태를 정수로 표현가능해도 그 값이 너무 큰 경우 실제 필요한 메모리보다 더 많은 메모리를 사용해서 불합리적이므로 맵이 효율적.
              std::unordred_map같은 해시 테이블은 일반적인 맵/딕셔너리 구조보다 빠르게 키를 찾고 검색 가능(배열보다 느림)
              std::map은 std::unordered_map보다 자유도가 높다. std::unordered_map은 동일한 기능을 제공하는 것은 가능하지만 기본적으로 키로 사용 불가능한 자료형에 대해서는 직접 해싱 함수를 만들어 사용해야 함.
              
              
           캐시 사용 방법을 위해 만족해야 할 것
            1.유효성 : 캐시의 키 값은 서로 다른 상태에 대해 충돌이 발생하지 않도록 표현(같은 것을 표현하는 다양한 방식이 존재하는 경우)
            2.유용성 : 캐시 사용 방식이 너무 독특해서 캐시에 저장된 값을 참조하지 않는 경우가 아예 발생하지 않으면 의미 x (사용된 원소의 모든 인덱스를 키로 사용 --> 재참조 x)
            
         (d) Tabulation
          주어진 집합에 대해 가능한 모든 부분 집합의 합 목록을 얻고 싶은 경우.
            주어진 문제를 재귀식으로 표현하는 것은 다차원 상태 표현과 분기 구조에는 잘 부합함
            but, 표형식 해법은 복잡한 계층을 for/while 문법에 의한 단순한 반복문 구조로 표현해야 함.
            1)제일 먼저 할 일 --> 기조 조건
            2)서로 다른 상태에 대한 해법을 어떻게 저장할 것인지 결정하기 --> 일반적으로는 간단한 배열 or 벡터 이용
            
          -하향식 로직 : 합 목표치와 집합의 첫 인덱스에서 시작 vs 상향식 로직 : 부분집합의 합과 인덱스를 0으로 설정하여 시작
          
          Tabulation은 Memoization이나 Backtracking보다 느리나 모든 가능한 부분집합의 합에 대해 알 수 있다.
          
          
동적 계획법은 제대로 이해하는 것(다른 형태의 매개변수로 성능 향상이 가능)이 바람직하며 그림을 그려보는 작업도 도움이 된다.




  2.문자열과 시퀀스에 대한 동적 계획법
    데이터 시퀀스의 패턴 문제 --> 주로 문자열 검색, 비교, 문자열 재구성과 관련 있음.
    Ex) 버전 관리 시스템의 '비교' 기능.
    -최장 공통 부분 시퀀스(LCS, Longest Common Subsequence)(=최장 공통 부분 수열 문제)
        --> 중복되는 부분 문제를 포함하고 있다는 사실을 알 수 있음.
        
다른 사람의 도움 없이 많이 풀어 보고 지속적인 연습이 중요. 
    
  
  메모이제이션 : 현재 상태 값을 알기 위해 아직 구하지 않은 이전 상태 값을 재귀적으로 계산
  타뷸레이션 : 앞부분 상태부터 채워나가며 이 상태 값을 나중에 재사용함.
  
  
