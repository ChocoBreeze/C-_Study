목표 : 
        기본적인 동적 계획법 접근 방법을 다른 문제에 적용하는 방법을 설명할 수 있다.
        동적 계획법에 대한 폭 넓은 이해
        상태 공간 축소 개념(동적 계획법 풀이에 사용되는 차원 크기, 연산 횟수 등을 최적화)
  
  
  -P와 NP
    P : 다항 시간(polynomial time) 내에 해답을 구할 수 있음. - O(n), O(n^2), O(log n) 등으로 표현 가능.
    NP : 비결정적 다항 시간(non-deterministic polynomial time) 문제
    주어진 문제의 솔루션을 검증하는 것은 쉽지만, 실제 솔루션을 만들어내는 작업은 매우 어렵다.
    P = NP? 라는 질문의 대답은 아니오이지만, 증명은 되지 않은 상황.
    NP에 속하는 많은 문제는 NP-Complete로 알려져 있으며, 이들 문제는 특별한 특성을 공유합니다.
    만약에 NP 문제 중 하나를 다항 시간처럼 효율적으로 해결하는 솔루션이 발견된다면, 해당 솔루션을 수정하여 다른 모든 NP 문제를 효율적으로 해결이 가능.
    특정 방법이 최선인지 판별하는 작업(검증)이 솔루션을 만들어내는 작업과 같은 수준의 복잡도를 요구하게 되는 경우 NP-완전 문제라 하기 어려움.
    
  -부분 집합의 합 문제 다시 보기.
    검증 : P에 해당
    솔루션 구성 : 다항 시간 복잡도를 가지지는 않음. --> pseudo-polynomial time
    NP-Complete에 해당한다고 할 수 있음.
    
  -배낭 문제(5장) 다시 보기.
    설명 : 용량 제한이 있는 배낭과 서로 다른 가격과 무게를 갖는 여러 물건이 주어질 경우, 배낭의 제한 용량을 넘지 않으면서 가방에 넣은 물건들의 가격 합이 최대가 되는 물건 조합 구하기.
    대표적인 NP - Complete 문제.
    0-1 knapsack문제로 부분집합의 합 문제를 해결할 때 사용했던 상태 변환 로직과 유사한 공통점을 발견 가능.
      집합의 원소 개수와 집합 원소의 합으로 크기가 한정된 2차원 검색 공간을 탐색하면서 새로운 부분집합의 합을 찾을 수 있는지 여부를 결정함.
      차이점은 단순히 특정 부분집합의 합이 존재하는지 여부를 기록하는 것이 아닌 무게를 고려해 최대 가격을 찾는다는 점.
      
    부분집합의 합 문제에서 사용했던 알고리즘을 약간 수정해 배낭 문제에 대한 효과적인 동적 계획법 솔루션을 만들 수 있다.
    
    
  -무한 개수 배낭 문제(unbounded kanpsack problem).
    각 물건을 개수 제한 없이 배낭에 담을 수 있는 문제
    --> 효율적인 방법을 찾기 위한 문제
        상태 공간 축소(State Space Reduction) = 문제의 상태를 표현하기 위해 사용하는 공간의 크기가 최소화하도록 동적 계획법 알고리즘을 재구성하는 작업.
        주어진 문제의 본질 속의 특정 패턴을 찾거나 대칭을 이용하는 형태로 귀결됨.
           ex) 파스칼 삼각형
                -필요 공간 : N^2 -> N(N+1)/2
                -좌우 대칭 --> n행에 대해 n/2열만 계산
        *상태를 시뮬레이션하는 차원과 상태를 표현하는 차원이 같을 필요는 없다.
        --> 물건 인덱스가 필요가 없으며 캐시 공간은 1차원으로 해결이 가능하다.
    
    
*그래프와 동적 계획법

  -벨만-포드 알고리즘 다시 보기
    접근 방법 : 시작 정점, 정점 개수 V, 에지 개수 E로 주어진 그래프.
        1. 0부터 (v-1) 정점의 거리 값을 UNKNOWN으로 초기화, start 정점은 0으로 초기화
        2. 1부터 v-1 까지 반복 (전체 edge에 대해)
        3. 각각의 반복에서 모든 에지 검사, 에지의 시작 정점 거리 값이 UNKNOWN인지 확인 후 아닌 경우, 에지로 연결된 정점의 거리 값 계산(시작 정점 거리 값 + weight)
        4. 3번에서 구한 값과 인접한 정점 거리값 중 더 작은 값으로 갱신
        5. v-1까지 반복 한후 모든 에지에 대해 반복을 한 번 더 수행하여 음수 가중치 사이클 확인.
    성공 여부 : 주어진 문제가 최적 부분 구조를 갖는가..?에 달림
    중복 연산을 효과적으로 방지하는 법
        1. 두 정점 사이를 연결하는 비순환 경로의 최대 이동 횟수는 | V-1 | 번.
        2. N번 반복한 후 얻을 수 있는 시작 정점과 나머지 도달 가능한 모든 정점 사이의 최단 거리는 |N-1| 번 반복한 후 얻을 수 있는 최단 거리 + 인접 정점 사이 가중치.
        
    -벨만-포드 : 하나의 정점에서 시작, 나머지 모든 정점까지의 최단 경로를 찾는 단일 시작 최단 경로 문제
    -존슨 : 모든 정점 사이의 최단 경로를 계산하는 모든 쌍 최단 경로 문제.(벨만-포드(동적 계획법) + 다익스트라(그리디))
    
    -하향식 해법으로 벨만-포드 알고리즘 이해하기
        
    -Floyd-Warshall algorithm(플로이드-워셜 알고리즘) 
        벨만-포드 알고리즘의 중요한 점 : 그래프의 두 정점 사이의 최단 경로가 출발 정점에서 시작하는 다른 최단 경로와 최종 목표 정점으로 연결된 에지의 조합으로 구성된다는 점.
        위의 언급된 중요한 점의 좀 더 광범위한 일반화가 적용된다는 점.
          논리 : 정점 A와 정점 B사이의 최단 거리가 AB이고 정점 B와 정점 C사이의 최단 거리는 BC이면 정점 A와 C 사이의 최단 거리는 AB + BC이다.
        논리 + 벨만-포드 알고리즘의 결합 --> 플로이드-워셜
        정점들에 대해 V^3만큼 반복하여 결과를 얻을 수 있음.
        그래프의 모든 정점을 중간 정점으로 사용하면서 지속적으로 결과 정확도를 향상시킴.
        모든 정점을 시작 정점과 목표 정점으로 사용하고, 동시에 모든 정점을 중간 정점으로 사용하면서 테이블에는 모든 정점 쌍 사이의 최단 거리가 저장됨.
        음수 에지의 경우 별도의 처리를 수행해야 함.
        
      모든 상황에서 Floyd-Warshall algorithm이 최선이라고 할 수는 없으며, 많은 수로 구성된 밀집 그래프(dense graph)의 경우에 사용하는 것이 유리함.
      벨만-포드 O(V*E) - 하나의 정점 기준.
      플로이드-워셜 O(V^3)
      
      
플로이드-워셜 vs 존슨 // 둘 중 무엇을 선택할지는 입력 그래프 구조에 따라
구현의 용이성 측면에서 보면 효율적이고 구현이 쉽기 때문에 플로이드-워셜이 더 좋음..

다양한 상황에 다양한 기법을 
